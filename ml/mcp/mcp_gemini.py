import argparse
import os
import json
import asyncio
from typing import Optional
from contextlib import AsyncExitStack
import google.generativeai as genai
from google.generativeai.types import HarmCategory, HarmBlockThreshold
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client

# --- Configuration ---
# To run this, you must have your GOOGLE_API_KEY set as an environment variable.
# Example: export GOOGLE_API_KEY="your_api_key_here"

try:
    genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
except KeyError:
    print("ERROR: The GOOGLE_API_KEY environment variable is not set.")
    print("Please set it to your Google API key to proceed.")
    exit(1)


class GeminiMCPClient:
    """A client that uses Gemini to generate MCP tool calls."""

    def __init__(self):
        self.session: Optional[ClientSession] = None
        self.exit_stack = AsyncExitStack()
        self.available_tools: list = []

    async def connect_to_server(self, server_script_path: str):
        """Connect to an MCP server and fetch its available tools."""
        is_python = server_script_path.endswith(".py")
        is_js = server_script_path.endswith(".js")
        if not (is_python or is_js):
            raise ValueError("Server script must be a .py or .js file")

        command = "python3" if is_python else "node"
        server_params = StdioServerParameters(
            command=command, args=[server_script_path], env=None
        )

        stdio_transport = await self.exit_stack.enter_async_context(
            stdio_client(server_params)
        )
        stdio, write = stdio_transport
        self.session = await self.exit_stack.enter_async_context(
            ClientSession(stdio, write)
        )
        await self.session.initialize()

        # Fetch and store tools from the server
        response = await self.session.list_tools()
        self.available_tools = [
            {
                "name": tool.name,
                "description": tool.description,
                "input_schema": tool.inputSchema,
            }
            for tool in response.tools
        ]
        print(
            "\nFetched tools from server:\n",
            self.available_tools,
        )

    async def generate_mcp_call(self, query: str) -> str:
        """Uses the Gemini API to generate an MCP tool call from a user query."""
        if not self.available_tools:
            return "Error: No tools available. Is the client connected to a server?"

        model = genai.GenerativeModel(
            model_name="gemini-2.5-flash",
            safety_settings={
                HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_ONLY_HIGH,
            },
        )

        print("\n--- Calling Gemini API ---")
        response = model.generate_content(
            query, tool_config={"function_calling_config": "ANY"}
        )

        print("\n--- Gemini API Raw Response ---")
        print(response)
        print("--- End of Raw Response ---\n")

        # Check if the model decided to call a tool
        if (
            not response.candidates[0].content.parts
            or not response.candidates[0].content.parts[0].function_call
        ):
            text_response = response.candidates[0].content.parts[0].text
            return f"No tool call generated by the model. Model response: '{text_response}'"

        tool_call = response.candidates[0].content.parts[0].function_call
        mcp_call = {"tool": tool_call.name, "args": dict(tool_call.args)}
        return json.dumps(mcp_call, indent=2)

    async def cleanup(self):
        """Clean up resources."""
        await self.exit_stack.aclose()


async def main():
    parser = argparse.ArgumentParser(
        description="CLI to generate weather MCP calls using Gemini."
    )
    parser.add_argument(
        "--query", required=True, help="Natural language query for the weather API."
    )
    parser.add_argument(
        "--server_script",
        required=True,
        help="Path to the MCP server script (e.g., weather.py).",
    )
    args = parser.parse_args()

    print(f"User Query: '{args.query}'")

    client = GeminiMCPClient()
    try:
        await client.connect_to_server(args.server_script)
        mcp_json_call = await client.generate_mcp_call(args.query)
        print("\nGenerated MCP Call:")
        print(mcp_json_call)
    finally:
        await client.cleanup()


if __name__ == "__main__":
    asyncio.run(main())
