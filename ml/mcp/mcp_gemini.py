import argparse
import os
import json
import google.generativeai as genai
from google.generativeai.types import HarmCategory, HarmBlockThreshold

# --- Configuration ---
# To run this, you must have your GOOGLE_API_KEY set as an environment variable.
# Example: export GOOGLE_API_KEY="your_api_key_here"

try:
    genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
except KeyError:
    print("ERROR: The GOOGLE_API_KEY environment variable is not set.")
    print("Please set it to your Google API key to proceed.")
    exit(1)

# --- Tool Definitions ---
# These definitions must exactly match the tools available on the MCP server.
# They inform the Gemini model about the functions it can call.

tools = {
    "get_alerts": {
        "name": "get_alerts",
        "description": "Get weather alerts for a US state.",
        "parameters": {
            "type": "OBJECT",
            "properties": {
                "state": {
                    "type": "STRING",
                    "description": "Two-letter US state code (e.g. CA, NY)",
                }
            },
            "required": ["state"],
        },
    },
    "get_forecast": {
        "name": "get_forecast",
        "description": "Get weather forecast for a location.",
        "parameters": {
            "type": "OBJECT",
            "properties": {
                "latitude": {
                    "type": "NUMBER",
                    "description": "Latitude of the location",
                },
                "longitude": {
                    "type": "NUMBER",
                    "description": "Longitude of the location",
                },
            },
            "required": ["latitude", "longitude"],
        },
    },
}


def generate_mcp_call(query: str) -> str:
    """Uses the Gemini API to generate an MCP tool call from a user query."""
    model = genai.GenerativeModel(
        model_name="gemini-2.5-flash",
        tools=list(tools.values()),
        # For safety, let's block harmful content.
        safety_settings={
            HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_ONLY_HIGH,
        },
    )

    response = model.generate_content(query)

    print("response:", response)

    # Check if the model decided to call a tool
    if (
        not response.candidates[0].content.parts
        or not response.candidates[0].content.parts[0].function_call
    ):
        # If no tool call is generated, return a message indicating this.
        # We can also include the model's text response if available.
        text_response = response.candidates[0].content.parts[0].text
        return f"No tool call generated by the model. Model response: '{text_response}'"

    tool_call = response.candidates[0].content.parts[0].function_call
    # Format the tool call into the MCP JSON format.
    mcp_call = {"tool": tool_call.name, "args": dict(tool_call.args)}
    return json.dumps(mcp_call, indent=2)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="CLI to generate weather MCP calls using Gemini."
    )
    parser.add_argument(
        "--query", required=True, help="Natural language query for the weather API."
    )
    args = parser.parse_args()

    print(f"User Query: '{args.query}'")
    mcp_json_call = generate_mcp_call(args.query)
    print("\nGenerated MCP Call:")
    print(mcp_json_call)
